# SQL инъекции

Тема в основном интересна просто нереальным количеством заблуждений, с ней связанных. В чем отметился и основной учебник, о чем будет отдельно сказано ниже.

Само по себе понятие инъекции не представляет из себя ничего сложного:   
Поскольку SQL запрос представляет из себя программу на языке SQL, и мы формируем эту программу динамически, добавляя в неё элементы на лету, то эти элементы могут повлиять на синтаксис программы, и привести - в лучшем случае - к ошибкам, а в худшем - к намеренной манипуяции запросом.

### Пример

Пример такой манипуляции показан в известнейшем комиксе, https://xkcd.ru/327/

Допустим, РНР код выглядит так - мы просто подставляем переменную 

    $sql = "INSERT INTO Students VALUES ('$name')";
    
а в $name у нас будет `Robert'); DROP TABLE Students; -- `

что при этом произойдёт?

- сначала в $name идет имя, хотя это и не обязательно - можно было бы сразу поставить закрывающую кавычку. Добавлено для художественности
- затем одинарная кавычка, которая закрывает строковый элемент
- затем идет скобка, которая закрывает оператор VALUES
- затем точка с запятой, которая завершает запрос
- затем пишется вредоносный запрос `DROP TABLE Students;`
- затем идет оператор комментария `-- `, текст после которого игнорируется базой данных, чтобы эти остатки не помешали второму запросу (можно, кстати, обойтись и без них)

И в итоге получается вот такой, *ситаксически корректный* SQL

    INSERT INTO Students VALUES ('Robert'); DROP TABLE Students; -- ');

Который, при *определенных условиях*, вполне может быть выполнен, в результате мы не досчитаемся таблицы Students в нашей БД. Вопросы, которые сразу возникают, например, откуда атакующий знает имя таблицы, являются вполне решаемыми, но это уже выходит за рамки данной статьи. 

Тот факт, что  этот запрос не будет выполнен при использовании стандарной футкции `mysqli_query()` (поскольку она может выполнять только один запрос за раз, и выдаст ошибку если передать два) **не должен нас успокаивать ни в малейшей степени**. Применимость того или иного эксплойта в конкретных условиях - это *совсем отдельный* вопрос. Поскольку очень важно различать два понятия: саму уязвимость, принципиальную возможность инъекции, и *конкретный эксплойт*. Эти два понятия постоянно путают, и это порождает полный хаос в рассуждениях.

В данном случае мы говорим об инъекции. О принципиальной возможности модифицировать SQL код. И эту возможность мы прекрасно продемонстрировали. 

То, что данный код сработает не всегда, не говорит вообще ни о чем. Если не получится удалить таблицу - получится слить всю базу данных, что тоже не сахар. Или  сделать себя супер-админом, или авторизоваться без пароля, или начислить 100500 денег на баланс. Все эти вещи, будучи весьма романтичными и по-своему увлекательнами, нам, в рамках данного курса **абсолютно не интересны**. Как и красивые загадочные термины типа "слепая SQL инъекция", "инъекция второго порядка", "инъекция базирующаяся на времени отклика"... 

И всё потому, что всё перечисленное выше - это эксплойты. Способы использовать существующую уязвимость. Которые, повторюсь, с точки зрения защиты нам совершенно **не интересны**. Хуже того - попытки как-то защищаться от конкретных эксплойтов приводят к совершенно идиотским идеям типа запрещать во входящих данных символ комментария, слово delete и пр. Это всё полная чушь, которая мало того что не имеет ни малейшего смысла, не только ухудшает функционал приложения (ну что это за база данных, которая не разрешает хранить определённые слова? ) но и является фатальной с точки зрения защиты: количество эксплойтов по определению бесконечно, и защитившись от десяти, мы пропустим одиннадцатый. И поэтому,

**Защищаться надо не от эксплойтов, а от инъекции.** То есть предотвращать *саму возможность* модифицировать код запроса.  

И если мы защитимся от самого факта инъекции, то все эти красивые слова, и миллионы хитроумных эксплойтов рассыпятся в прах, станут безобидным мусором. То есть наша защита будет этаким Нео, который не глядя отмахивается от летящих со всех сторон пуль.

### Заблуждения

С защитой так же связано огромное количество заблуждений, мифов, и суеверий.

Самое, пожалуй, катастрофическое - как по распространённости, так и по последствиям - это утверждение, что функция `mysqli_real_escape_string()` *предназначена* для защиты от инъекций. На самом деле это полная чушь, к инъекциям эта функция имеет только косвенное отношение, но главное - никогда не должна применяться в целях защиты. Печальные последствия этого заблуждения можно наблюдать сплошь и рядом, в частности, [в коде](https://github.com/htmlacademy-php/60877-yeticave-12/blob/ad324e4c3d8968bcc48654df78f50264dede249c/lot.php#L10) студентов, следующих близоруким рекомендациям из основного учебника. Проблема в том, что эта функция защищает от инъекций только в **строках**. То есть тех участках запроса, которые заключены в кавычки. Поскольку собственно эти кавычки-то и экранирует (а заодно и сам экранирующий символ). Для всех остальных элементов запроса она **бесполезна чуть более, чем полностью**. И мы можем спокойно приписать к `$id` из кода выше любой SQL (только избегая кавычек, что, хотя и затрудняет задачу атакующего, отнюдь не делает её нерешаемой). То есть понимая, для чего на *самом деле* служит эта функция, применять её можно. Но не нужно. Поскольку её использование сложнее чем подготовленные выражения, и плюс к тому при ее использовании легко запутаться и пропустить инъекцию.

Так же очень большой вред приносят всякие *рассуждения*:

 - многие допускают ошибку, пытаясь бороться против каких-то косвенных деталей, вместо того чтобы защищаться от инъекций (мы говорили об этом выше)
 - также, особняком в этом ряду стоят рассуждения о том, какие данные надо защищать, а какие - нет. Это самый треш. Всегда, абслютно всегда в таких рассуждениях допускается ошибка, и в итоге "абсолютно безопасные данные" пропускают инъекцию. При защите следует исходить из принципа, **Защищать надо запрос, а не данные**. Что это за данные, откуда они пришли, насколько безопасны - нас не должно интересовать от слова "совсем". Игнорирование этого принципа рано или поздно приведет к инъекции. Нас всегда должен интересовать только конечный **пункт назначения**, а не источник данных. Данные идут в SQL запрос? Защищаем. Простой как 3 копейки и на 100% эффективный принцип. 
- ещё часто можно встретить рассуждения типа "ну у меня учебный проект, его никто ломать не будет". Это настолько многоплановая глупость, что у меня даже нет слов. Если подумать, то
  - инъекция вляется лишь частным случаем ошибки запроса. Если код пропускает инъекции, значит от также подвержен и ошибкам. Ошибки в учебном проекте уж точно не нужны
  - зачем вообще сначала учиться делать неправильно, а потом переучиваться?!
  - любой проект развивается и в какой-то момент превращается из учебного в рабочий
 
 *Рассуждать* в деле защиты не следует. А следует просто применять простой набор правил, приведенный ниже.

# Защита

Защита от SQL инъекций сводится к строгому следованию двум пунктам

1. Любые *данные* должны добавляться в запрос **только** через плейсхолдеры
2. Любые другие элементы запроса должны выбираться из *белого списка* - заранее прописанных в нашем коде значений.

Почему важно первое? Потому что добавленное через плейсхолдер значение гарантированно предохраняет нас от любых ошибок, которые могут быть вызваны попавшими в запрос данными, и в частности - от инъекций. Все остальные способы требуют целого свода правил и оговорок. А это очень простой для запоминания и применения*, а главное - однозначный способ. Подробно он был рассмотрен в главе 5.2, но для закрепления, повторим его здесь тоже:

### Защита данных

Хотя сама БД различает [много разных типов данных](https://dev.mysql.com/doc/refman/8.0/en/literals.html), с практической точки зрения они все сводятся к строкам, числам и примкнувшему к ним `null`. И все эти типы данных *прекрасно* передаются в запрос через подготовленные выражения (также известные как параметризованные запросы).

Чтобы выполнить параметризованный запрос, необходимо выполнить 4 действия:

1. Заменить все переменные в запросе на специальные маркеры, которые называются *плейсхолдеры* или *параметры*, а по сути - просто знаки вопроса
2. Подготовить запрос к исполнению с помощью функции `prepare()`. Эта функция принимает строку запроса и возвращает экземпляр специального класса `mysqli_stmt`, с которым в дальнейшем и производятся все манипуляции
3. Привязать переменные к запросу с помощью `bind_param()`. Это очень интресная функция. Она принимает в качестве параметров все переменные, которые должны попасть в запрос, в том же самом порядке, в котором стоят плейсхолдеры в запросе. Но кроме того, сначала в этой функции должны быть указаны типы для всех переменных, в виде строки, где тип переменной обозначается одной буквой. То есть букв в этой строке должно быть ровно столько, сколько дальше будет переменных. К счастью, можно особо не париться с типами и для всех переменных указывать тип "s". 
4. Выполнить запрос с помощью с помощью `execute()`. Эта функция выполняется без параметров
  - после выполнения запроса SELECT, надо так же получить результат запроса через метод `get_result()`

### Защита остальных элементов запроса

Редко, но *бывает* так, что нам надо добавить в запрос переменную, которая сдержит не данные, а, скажем, имя поля. В этом случае замена на плейсхолдер не сработает (и скажет об этом сразу), а строковое экранирование (mysqli_real_escape_string) поможет как мёртвому припарки, и будет пропускать все возможные инъекции (но мы об этом узнаем только постфактум). 

К счастью, в случае имен полей/команд SQL, список возможных вариантов заведомо ограничен. Поэтому мы можем заранее прописать все варианты в коде, и выбирать из них.

    $allowed = ["name", "price", "qty"]; // перечисляем все варианты
    if(array_search($_GET['order'], $allowed) === false); // ВАЖНО использовать === false
        throw new \InvalidArgumentException("Несуществующее поле"); 
    }
    
и дальше уже можем безопасно подставлять `$_GET['order']` в запрос. Реализации данного правила могут быть разными, но суть должна сводиться к одному - подставляемое в запрос значение должно проверяться по заранее состалвенному списку, или - еще лучше - выбираться из него 

## Упрощение работы с подготовленными выражениями

Выше я конечно погорячился, написав что применять подготовленные запросы *просто*. Писать по 4 строчки на каждый запрос - это как-то уж очень занундно. Но это правда смотря с чем сравнивать. 4 строчки все-таки лучше столба из `mysqli_real_escape_string` когда у нас запрос на вставку из 10 полей (не говоря уже о том что этот столб не гарантирует защиту).

Впрочем, не все подготовленные выражения одинаково сложны. В PDO можно написать подготовленный запрос в одну строчку:

    $pdo->prepare("INSERT INTO t (name, price, qty) VALUES (?,?,?)")->execute([$name, $price, $quantoty]);
    
Но в mysqli доступен только вот такой замысловатый ситаксис, который мы освоили выше. К счастью, нашей профессией является программирование, а это значит что мы можем сами для себя создавать какие угодно инструменты для упрощения каких угодно операций (в конце концов, даже в PDO - зачем вызывать две функции, prepare и execute, если нам надо выполнить только один запрос)?

В частности, мы вполне можем написать функцию, которая сделает подготовленные запросы такими же простыми в использовании, как и запросы без переменных.

> **Важно!** Написание этой функции будет представлять из себя отдельную, дополнительную задачу, в рамках задачи **8.7. Завершаем работу над проектом**.  Ни в коем случае нельзя применять её с самого начала. Необходимо сначала освоить исходный синтаксис подготовленных выражений. Выполнение этой задачи не является обязательным, при желании её можно пропустить. 

На самом деле в коде проекта, в файле helpers.php, уже есть пример такой функции, но на мой вгляд она просто чудовищная: неимоверно раздута, с кучей лишнего кода (но при этом не включает в себя некоторые нужные элементы). Не говоря уже о таких ужасных вещах, как вывод ошибок прямо на экран, что опять же является признаком ученического, а не профессионального подхода. Эта функция явно писалась студентом под себя, совершенно без учета того факта, что она может когда-нибудь использоваться на боевом сайте: **посетителю сайта** совершенно неинтересно читать про то, что программисту "Не удалось инициализировать подготовленное выражение". Такого рода ошибки **никогда** не должны выводиться на экран (подробнее об этом можно почитать в [приложении 1](https://github.com/ro-htmlacademy/textbook/blob/main/appendix1.md)). И почему в курсе для них сделано исключение, остаётся для меня загадкой. Не говоря уже о том, что мы при подключении уже задали режим выбороса ошибок mysql, и вручную проверять ошибки просто не нужно. 

Так же в коде функции есть много другого лишнего кода, например попытка определить тип переменной. Этого делать никогда не надо, по двум причинам

- во-первых, это не нужно. Mysql с огромным удовольствием примет любые данные как строки. 
- во-вторых, такое "вынюхивание" типа может привести к совершенно катастрофическим последствиям. Дело в том, что как и в РНР, в mysql используется слабая типизация. И в частности любая строка равна числу ноль. А это значит, что запрос вида `"delete from users where email=0` **удалит всех пользователей** в таблице! В то время как запрос `delete from users where email='0'` не удалит ни одной строки. Как говорят англичане, "Better safe than sorry", что можно перевести как "Лучше подстраховаться, чем потом пожалеть". И забыть про вынюхивание типа переменной как страшный сон. А просто всегда привязывать все переменные с типом `s`.

На тот редкий случай, когда надо будет указать какой-то другой тип, отличный от s, мы просто добавим к функции необязательный параметр, в котором можно будет указать типы вручную.

Соответственно, функция должна будет принимать три обязательных параметра (объект mysqli, SQL запрос и массив с переменными) и один необязательный - строку с типами. после этого надо будет подготовить запрос и привязать к нему переменные. Если типы не были указаны - значит формируем строку из одних букв s по числу параметров.

После этого нам надо будет вызвать bind_param  с неизвестным числом переменных. До версии 5.4 такой вызов представлял реальную *боль*, но с тех пор в РНР появился гениальный оператор распаковки переменных или три точки, `...`. С его помощью можно вызвать функцию, которая ждет отдельные переменные, передав в неё массив, вот так: 

    $stmt->bind_param($types, ...$params);

Ну и напоследок, мы включим в состав функции исполнение запроса, поскольку писать его отдельно не имеет ни малейшего смысла. 

Важно! Функция **не** должна возвращать  результат get_result(). По той простой причине, что она будет использоваться не только для запросов SELECT, а у запросов на вставку или обновление никакого result нету. Поэтому просто возвращаем $stmt. Есл хотим функцию для запросов SELECT  - можно написать еще одну. Или класс.
Но в самом простом случае можно написать 

    $result = db_get_prepare_stmt($mysqli, $sql, [$var1, $var2, ...])->get_result();
