# Дифференцированный подход к отображению ошибок

Одним из важных отличий профессионального кода от учебного является дифференцированный подход к отображению ошибок.   
И в рамках профессионального курса очень важно затронуть эту тему.

Авторы учебного кода практически никогда не задумываюся о том, что их сайт по идее когда-нибудь "встанет на боевое дежурство", и при этом его аудитория кардинальным образом поменяется: сам программист уже не будет сидеть и видеть результат работы каждого скрипта. В то же время у сайта появятся пользователи, у которых совершенно другие интересы. 

И интересы эти подчас диаметрально противоположные. Судите сами: 
- *Программисту* надо видеть **каждую** ошибку, которая происходит на сайте, причём **в мельчайших подробностях**. 
- В то время как *пользователям* системные ошибки показывать ни в коем случае **нельзя!**
 
Программисту необходим подробный текст ошибки, а пользователю наоборот - уклончивое сообщение о том что на сайте временные технические работы, но главное - остаться в привычном интерфейсе, чтобы было куда нажать.

Но что самое удивительное - это что такие различные интересы очень легко удовлетворить! Для этого надо следовать простым правилам:

- код проекта всегда только *порождает* ошибки, но никогда сам не занимается их обработкой (и тем паче - выводом их на экран)
- всегда выставляется **максимальный** уровень отображения ошибок
- режим работы сайта четко делится на режим разработки и боевой режим 
- в режиме разработки ошибки отображаются прямо на экране. Для этого можно настроить РНР в конфигурации сервера, но для надёжности я предлдагаю написать прямо в РНР коде две строчки

        error_reporting(E_ALL); // задаем максимальный уровень, чтобы РНР нас информировал обо ВСЕХ ошибках без исключений
        ini_set('display_errors',1); // задаем режим вывода на экран
- в боевом режиме ошибки никогда не показываются на экране, а пишутся в **лог ошибок**. При этом пользователю показывается специальная страница ошибки с определенным кодом НТТР, подобная тем что будут добавлены впоследствии к коду учебного сайта, но только для кода 500.

> (*глядя на эти простые правила становится понятно, почему меня так вымораживает подход к отображению ошибок базы данных, принятый в основном учебнике: все ошибки тупо выводятся сразу на экран, без возможности как-то изменить такое поведение. Это один из наиболее характерных признаков ученического подхода. О том, как  привести ошибки БД к общему знаменателю, показано в исправленной главе 5.1*)

Разделение режимов можно сделать по-разному, но одним из самых простых способов будет использование конфигурационной опции РНР `display_errors`. В зависимости от её значения РНР будет либо показывать ошибки на экране, либо не будет. Также в боевом режиме надо использовать опцию `log_errors`, которая автоматически будет писать все ошибки в лог.

И останется только сделать показ красивых ошибок для пользователя. 

> **Внимание!** Данный материал является факультативным. Изложенная ниже информация служит в первую очередь для ознакомления с профессиональными арактиками и не относится к проходимому курсу. При желании можно реализовать рекомендованный ниже подход, но только на завершающем этапе работы над проектом.  

Это сделать совсем несложно, в РНР есть функция [set_exception_handler()](https://www.php.net/manual/ru/function.set-exception-handler.php), которая  принимает в качестве аргумента либо имя функции, либо сам код функции, которая будет вызываться в случае, если код выбрасывает исключение, которое не было поймано.

И дальше там только останется определить - не в боевом ли режиме запустился сайт - и если да, то написать два простых обработчика: ошибок и исключений.

Вообще, обработчики могут быть очень развесистыми. Но для нашего случай подойдут совсем простые, буквально в пару строк.

Само разделение режимов обычно делается внутри обработчика, но в простейшем случае можно сделать условие, которое будет проверять значение `display_errors`, 

То есть самый простой вариант пользовательского обработчика исключений будет таким

```php
if (!filter_var(ini_get('display_errors'),FILTER_VALIDATE_BOOLEAN)) {
    set_exception_handler(
        function ($e){
            error_page(500);
        });
}
```
где error_page() - это функция, которая отображает страницу сайта с текстом ошибки.

Подробнее можно почитать на странице документации по функции     
Вкратце, эта функция принимает в качестве аргумента либо имя функции, либо сам код функции, которая будет вызываться в случае, если код выбрасывает исключение, которое не было поймано. То есть всё очень просто: произошла ошибка в коде, которая привела к выбросу исключения (например, ошибка SQL запроса)? Вызывается код, который описан выше. 

Теперь останется добавить подобным обрадом пользовательский обработчик *ошибок*, который будет либо так же вызывать error_page(), либо конвертировать все ошибки в исключения, выбрасывая внутри себя исключение с текстом ошибки.


