# Индексы

Для чего нужен индекс? 
Для быстрого поиска или сортировки данных. 

По сути, база данных - это просто файл на диске, в котором одна за другой лежат записи. 
Со всеми вытекающими отсюда проблемами. Например - ужасающе медленным поиском. Чтобы найти строку, которая лежит в файле на 50000-й позиции, надо сначала прочитать 49000 лежащих перед ней. 

Для быстрого поиска и служит индекс. 

В первую очередь делается **первичный индекс**, который нужен самой базе данных, чтобы быстро находить в файле нужную запись. Потому что в нем собственно и лежит смещение в файле, по которому записаны данные нужной строки. И её размер. То есть можно сразу считать нужную строку из базы, а не перебирать все по одной.

**Обычный индекс** - это просто все значения одного поля, заранее отсортированные и лежашие в оперативной памяти.
При этом обычный индекс всегда внутри себя использует первичный. 

Допустим у нас в базе данных 100000 записей. нам нужна запись с именем Вася, которая лежит на 50000 месте
без индекса мы будем читать записи с диска по одной, и искать  них Васю
С индексом мы быстро, буквально в 2-3 шага, прямо в оперативной памяти найдем в индексе Васю. Дальше обычный индекс находит по первичному координаты записи на диске.
И в итоге мы сразу прочтем нужную строку, без того чтобы читать весь файл с данными перебирая записи по одной.


# Связи в реляционных БД

### Само понятие связи

Следует понимать, что все связи в реляционных БД - виртуальные. То есть они подразумеваются, но в (общем случае) никак физически не не обозначаются. По сути, реляционная БД - это набор отдельных таблиц, никак физически не связанных друг с другом. А все связи строятся во время построения запросов. Если надо связать две таблицы, то в таблицу добавляется поле, которое ссылается на определенную строку другой таблицы, обычно по id. При этом, чисто для удобства, имя поля включает в себя имя связанной таблицы, и поле, по которому строится связь, например `user_id`, `lot_id` и т.д.

### Материализация ~~чувственных идей~~ связей

Однако есть способ "материализовать" связи с помощью *внешних ключей*. Это позволяет установить физическую связь между таблицами для контроля целостности данных. С этой целью для поля-связки и добавляется внешний ключ. И в этом случае очень важно представлять себе сценарий действий базы данных при удалении (или изменении) информации из связанной таблицы. В основном, у нас есть два сценария: либо не дать удалить запись, которая связана с другими, либо при удалении записи удалить и все ссылки на неё.

Например, у нас есть блог посты, у которых есть категории и теги. При удалении необязательной информации, например тега, нам нежелательно чтобы наличие данного тега у нескольких постов препятствовало удалению. Нам просто надо удалить как сам тег, так и его упоминания в постах. 

В случае же если мы удаляем обязательный элемент - например категорию поста, то необходимо чтобы при попытке удалить категорию с существующими постами выдавалась ошибка.

> **Важно:** осмысленная работа с внешними ключами требует довольно много времени на проектирование и тестирование. И при этом наличие внешних ключей не является обязательным. Следует трезво взвесить свои возможности, и либо совсем отказаться от них, либо оставить внедрение до завершающих этапов проекта. 

Замечания по заданииям

# task4-module1 "9. Создаём схему БД личного проекта"

1. По опыту многих студентов, использовать визуальные средства для проектирования БД не очень удобно - больше мороки, чем пользы. При желании можно, но при возникновении проблем лучше проектировать в виде дампа (набора запросов). Потом можно загрузить готовый  дамп в визуальное средство и полюбоваться при желании.
1. При выполнении задания **не следует** создавать никакие индексы, кроме уникальных и первичных. 
Индексы начинают иметь смысл только в привязке к запросам, а данные у нас появятся только в следющем задани.
2. Поле с именем пользователя не следует делать уникальным. Пользователя мы идентифицируем по емейлу, а это значит что 
дополнительное поле логин перестает иметь смысл и вносит только путаницу.
Получается что вместо логина нам нужно просто отображаемое имя пользоваетля. А у разных людей вполне могут совпадать имена. 
Что вполне можно видеть на примере реально существующих соц.сетей

### Ошибка в ТЗ

В ТЗ написано, что у таблицы пользователей есть две связи. Это, конечно не так, никаких полей-связей в этой таблице не нужно. Эта таблица является родительской по отношению ко всем связанным с ней, и соответственно, поля-связи добавляются в дочерних таблицах.

### Поле типа CHAR

Почему-то почти все студенты любят использовать поле типа CHAR.   
Но вообще-то этот тип поля очень специфический и используется очень редко, для решения очень специальных задач. И кроме того,
- во-первых, он имеет смысл только тогда, когда все остальные поля в таблице тоже фиксированной длины
- во-вторых, следует понимать, что данные переменной длины, помещенные в поле типа char занимают гораздо больше места

Поэтому по умолчанию следует использовать тип VARCHAR

### Поле типа TIMESTAMP

Почему-то почти все студенты любят использовать поле типа TIMESTAMP.   
Однако его тоже надо использовать с осторожностью и в очень специальных случаях, понимая особенности его применения.
DATETIME же - гораздо более предсказуемый формат. Это поле, в отличие от timestamp, всегда вернёт вам то, что вы в него вводили:

```SQL
create table t(d1 timestamp, d2 datetime);
insert into t values ('2021-10-10 10:10:10', '2021-10-10 10:10:10');
set time_zone="europe/moscow";
select * from t;
set time_zone="america/new_york";
select * from t;
```
Поэтому по умолчанию дла хранения даты-времени следует использовать DATETIME


### Финальная структура

По завершении задания и создания базы данных на своем сервере mysql, обязательно сделайте *дамп*.   
Любая программа для работы с mysql умеет его делать.    
Дамп - это основной способ импорта/экспорта данных, но кроме того он показывает запросы, которыми БД будет создавать ваши таблицы.    
Надо сделать дамп и внимательно посмотреть, как выглядят выши запросы с точки зрения БД. возможно, вы увидитке какие-то недочёты.
Именно этот дамп я и предлагаю поместить в файл schema.sql.

# task4-module2 "10. Пишем SQL-запросы"


После добавления данных следует добавить индексы в дамп со схемой БД проекта.   
К выполнению этого задания следует подходить осознанно, а не механически. 

1. Обычные индексы для ускорения выборок, про которые говорится в задании 4-1: "Поля, по которым часто будут проходить выборки также должны быть с индексом". 
Это просто поля, которые участвуют в WHERE, для таблиц в которых планируется много данных, и у которых нет уникального или первичного индекса. 
Каждую строку добавления индекса снабдить комментарием, который поясняет - почему здесь нужен индекс
2. При желании можно добавить внешние ключи. При этом необходимо писать комментарий, который поясняет действие ключа при удалении или изменении связанной записи.
Этот комментарий даже более важен, чем в предыдущем пункте.
Также обязательно надо будет проверить все действия с данными в связанных таблицах. 




